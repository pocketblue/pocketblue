#!/bin/bash
# Rebind PMIC GLINK driver to re-establish device links after all
# USB-C components (FSA4480, PTN36502, USB controller) are ready
#
# This script is only run if Type-C functionality is not working.
# The kernel usually handles this automatically, but in some cases
# a rebind may help.

PMIC_GLINK_PATH="/sys/bus/platform/drivers/qcom_pmic_glink"
PMIC_GLINK_DEV="pmic-glink"
MAX_WAIT=30

# Function to check if Type-C port is functional
check_typec_port() {
    [ -d "/sys/class/typec/port0" ]
}

# Check if Type-C port already exists and is functional
if check_typec_port; then
    echo "Type-C port0 already exists, no rebind needed"
    exit 0
fi

# Check if driver exists
if [ ! -d "$PMIC_GLINK_PATH" ]; then
    echo "PMIC GLINK driver not found, skipping rebind"
    exit 0
fi

# Wait for PMIC GLINK device to be bound
echo "Waiting for PMIC GLINK device..."
for i in $(seq 1 $MAX_WAIT); do
    if [ -e "$PMIC_GLINK_PATH/$PMIC_GLINK_DEV" ]; then
        echo "PMIC GLINK device bound"
        break
    fi
    if [ $i -eq $MAX_WAIT ]; then
        echo "PMIC GLINK device not bound after ${MAX_WAIT}s, skipping rebind"
        exit 0
    fi
    sleep 1
done

# Function to check if a device is bound to its driver
check_device_ready() {
    local path="$1"
    local name="$2"
    
    if [ ! -d "$path" ]; then
        echo "  $name: not present (optional)"
        return 0
    fi
    
    if [ -d "$path/driver" ]; then
        echo "  $name: ready"
        return 0
    else
        echo "  $name: not ready"
        return 1
    fi
}

# Check if all suppliers are ready before rebinding
echo "Checking USB-C component status..."

# Wait for all components with timeout
ALL_READY=0
for attempt in $(seq 1 $MAX_WAIT); do
    READY_COUNT=0
    
    # FSA4480 on i2c bus 1
    if check_device_ready "/sys/bus/i2c/devices/1-0042" "FSA4480 (1-0042)"; then
        ((READY_COUNT++))
    fi
    
    # PTN36502 on i2c bus 4 (may not exist on all variants)
    if [ -d "/sys/bus/i2c/devices/4-001a" ]; then
        if check_device_ready "/sys/bus/i2c/devices/4-001a" "PTN36502 (4-001a)"; then
            ((READY_COUNT++))
        fi
    else
        ((READY_COUNT++))  # Not present, skip
    fi
    
    # USB controller
    if check_device_ready "/sys/bus/platform/devices/a600000.usb" "USB controller"; then
        ((READY_COUNT++))
    fi
    
    # QMP combo PHY
    if check_device_ready "/sys/bus/platform/devices/88e8000.phy" "QMP combo PHY"; then
        ((READY_COUNT++))
    fi
    
    # Need at least 3 components ready (FSA4480, USB, PHY)
    if [ $READY_COUNT -ge 3 ]; then
        ALL_READY=1
        break
    fi
    
    echo "Waiting for USB-C components... ($attempt/$MAX_WAIT)"
    sleep 1
done

if [ $ALL_READY -eq 0 ]; then
    echo "Not all USB-C components ready, skipping rebind"
    exit 0
fi

echo "All required USB-C suppliers ready, attempting PMIC GLINK rebind..."

# Unbind
if echo "$PMIC_GLINK_DEV" > "$PMIC_GLINK_PATH/unbind" 2>/dev/null; then
    echo "  Unbound PMIC GLINK"
else
    echo "  Failed to unbind PMIC GLINK (may already be unbound)"
fi

# Delay to allow cleanup
sleep 2

# Rebind
if echo "$PMIC_GLINK_DEV" > "$PMIC_GLINK_PATH/bind" 2>/dev/null; then
    echo "  Rebound PMIC GLINK successfully"
else
    echo "  Note: PMIC GLINK rebind returned error (may already be bound)"
fi

# Wait for Type-C port to appear
echo "Waiting for Type-C port to appear..."
for i in $(seq 1 10); do
    if check_typec_port; then
        echo "Type-C port0 is now available"
        # Display port info
        if [ -f "/sys/class/typec/port0/data_role" ]; then
            echo "  Data role: $(cat /sys/class/typec/port0/data_role)"
        fi
        if [ -f "/sys/class/typec/port0/power_role" ]; then
            echo "  Power role: $(cat /sys/class/typec/port0/power_role)"
        fi
        exit 0
    fi
    sleep 1
done

echo "Warning: Type-C port0 still not available after rebind"
echo "This may indicate a hardware issue or missing firmware"
exit 0
