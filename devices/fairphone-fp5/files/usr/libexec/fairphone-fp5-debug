#!/bin/bash

set -uo pipefail

log_run() {
    echo "+ $*" >&2
    "$@"
}

section() {
    echo ""
    echo "==============================="
    echo "  $1"
    echo "==============================="
    echo ""
}

heading() {
    echo "--- $1 ---"
}

get_session_bus_address() {
    local uid
    uid=$(log_run id -u "$1" 2>/dev/null) || return 1
    local bus="/run/user/${uid}/bus"
    [ -S "$bus" ] && echo "unix:path=$bus"
}

echo "========================================"
echo "Fairphone 5 Debug Report — $(date -Iseconds)"
echo "========================================"
echo ""

echo "=== Kernel ==="
log_run uname -r
echo ""

echo "=== Systemd ==="
log_run systemctl --version | head -1
echo ""

echo "=== Key services ==="
for svc in \
    bluetooth.service \
    hexagonrpcd-adsp-sensorspd.service \
    iio-sensor-proxy.service \
    rmtfs.service \
    tqftpserv.service; do
    state=$(log_run systemctl is-active "$svc" 2>/dev/null)
    enabled=$(log_run systemctl is-enabled "$svc" 2>/dev/null)
    printf "  %-45s active=%-10s enabled=%s\n" "$svc" "$state" "$enabled"
done
echo ""

echo "=== Remoteproc ==="
for rproc in /sys/class/remoteproc/remoteproc*/; do
    [ -f "${rproc}name" ] && echo "  $(basename "$rproc"): $(cat "${rproc}name") — $(cat "${rproc}state")"
done
echo ""

echo "=== PD mapper ==="
log_run lsmod | grep qcom_pd_mapper || echo "  qcom_pd_mapper module not loaded"
echo ""

echo "=== QRTR ==="
if command -v qrtr-lookup &>/dev/null; then
    log_run qrtr-lookup 2>/dev/null | head -20
else
    echo "  qrtr-lookup not available"
fi

section "BLUETOOTH"

heading "BT firmware files"
log_run ls -la /usr/lib/firmware/qca/msbtfw11.* /usr/lib/firmware/qca/msnv11.* 2>/dev/null || echo "  none"
echo ""

heading "BT firmware conflicts check"
echo "  Compressed firmware that should NOT exist (conflicts with FairBlobs):"
bt_conflicts=$(find /usr/lib/firmware/qca/ -maxdepth 1 \( -name 'msbtfw11.*.xz' -o -name 'msbtfw11.*.zst' -o -name 'msnv11.*.xz' -o -name 'msnv11.*.zst' \) 2>/dev/null)
if [ -n "$bt_conflicts" ]; then
    echo "$bt_conflicts"
else
    echo "  none (good)"
fi
echo "  .tlv symlink check:"
log_run ls -la /usr/lib/firmware/qca/msbtfw11.tlv 2>/dev/null || echo "  MISSING — driver tries .tlv first, should be symlink to .mbn"
echo "  Firmware in initramfs:"
log_run lsinitrd 2>/dev/null | grep -E "msbtfw|msnv" || echo "  not found in initramfs"
echo ""

heading "BT devices"
log_run ls -la /sys/class/bluetooth/ 2>/dev/null || echo "  none"
echo ""

heading "BT modules"
log_run lsmod | grep -E "bluetooth|btqca|hci_uart|rfkill" || echo "  none loaded"
echo ""

heading "rfkill"
log_run rfkill list bluetooth 2>/dev/null || echo "  unavailable"
echo ""

heading "bluetoothctl"
log_run timeout 3 bluetoothctl show 2>/dev/null | grep -E "Powered|PowerState|Name|Controller" || echo "  no controller"
echo ""

heading "btmgmt info"
log_run btmgmt info 2>&1 || true
echo ""

heading "BT dmesg"
log_run dmesg | grep -iE "bluetooth|qca.*setup|hci|btqca" | tail -20
echo ""

heading "BT systemd drop-ins"
log_run ls -la /usr/lib/systemd/system/bluetooth.service.d/ 2>/dev/null || echo "  none"
echo ""

heading "BT service logs"
log_run journalctl -b 0 -u bluetooth.service --no-pager -n 15 2>/dev/null

section "SENSORS & AUTO-ROTATION"

heading "fastrpc devices"
log_run ls -la /dev/fastrpc-* 2>/dev/null || echo "  none"
echo ""

heading "hexagonrpcd-adsp-sensorspd status"
log_run systemctl status hexagonrpcd-adsp-sensorspd.service --no-pager -n 5 2>/dev/null
echo ""

heading "hexagonrpcd-adsp-rootpd status"
log_run systemctl status hexagonrpcd-adsp-rootpd.service --no-pager -n 5 2>/dev/null
echo ""

heading "sensor persist directory"
log_run ls -la /mnt/vendor/persist/sensors/registry/ 2>/dev/null || echo "  MISSING — ADSP sensor calibration will fail"
log_run ls -la /mnt/vendor/persist/sensors/registry/registry/ 2>/dev/null || echo "  MISSING — ADSP temp.json writes will fail"
echo ""

heading "udev env on fastrpc-adsp"
log_run udevadm info /dev/fastrpc-adsp 2>/dev/null | grep -E "IIO_SENSOR_PROXY_TYPE|ACCEL_MOUNT_MATRIX" || echo "  no env vars set"
echo ""

heading "iio-sensor-proxy binary"
log_run rpm -q iio-sensor-proxy 2>/dev/null
log_run ldd /usr/libexec/iio-sensor-proxy 2>/dev/null | grep -iE "ssc|qrtr" || echo "  no SSC/QRTR libs linked"
echo ""

heading "iio-sensor-proxy systemd drop-ins"
log_run ls -la /usr/lib/systemd/system/iio-sensor-proxy.service.d/ 2>/dev/null || echo "  none"
echo ""

heading "iio-sensor-proxy service config"
log_run systemctl cat iio-sensor-proxy.service 2>/dev/null | grep -E "RestrictAddress|ExecStart|BusName|PrivateNetwork|Restart|After|Wants"
echo ""

heading "iio-sensor-proxy resolved sandbox settings"
log_run systemctl show iio-sensor-proxy.service -p RestrictAddressFamilies -p PrivateNetwork 2>/dev/null
echo ""

heading "iio-sensor-proxy SELinux"
echo "SELinux mode: $(getenforce 2>/dev/null || echo 'N/A')"
log_run semodule -lfull 2>/dev/null | grep -i qrtr || echo "  qrtr SELinux module not installed"
log_run ausearch -m avc --subject iiosensorproxy_t -ts boot 2>/dev/null | grep -c denied | xargs -I{} echo "  AVC denials this boot: {}"
echo ""

heading "iio-sensor-proxy service logs"
log_run journalctl -b 0 -u iio-sensor-proxy.service --no-pager -n 20 2>/dev/null
echo ""

heading "SensorProxy D-Bus properties"
log_run gdbus call --system --dest net.hadess.SensorProxy \
    --object-path /net/hadess/SensorProxy \
    --method org.freedesktop.DBus.Properties.GetAll \
    net.hadess.SensorProxy 2>/dev/null || echo "  SensorProxy not available on D-Bus"
echo ""

heading "Boot timing: sensor discovery vs GNOME Shell"
echo "  iio-sensor-proxy:"
log_run journalctl -b0 -u iio-sensor-proxy.service -o short-monotonic --no-pager 2>/dev/null | head -5
echo "  GNOME Shell:"
log_run journalctl -b0 -o short-monotonic --no-pager 2>/dev/null | grep "gnome-shell\[.*\]: GNOME Shell started" | head -2
echo ""

heading "Mutter orientation & touch-mode (via session bus)"
session_user=""
session_bus=""
while IFS= read -r line; do
    u=$(echo "$line" | awk '{print $3}')
    addr=$(get_session_bus_address "$u")
    if [ -n "$addr" ]; then
        session_user="$u"
        session_bus="$addr"
        break
    fi
done < <(log_run loginctl list-sessions --no-legend --no-pager 2>/dev/null | grep seat0)

if [ -n "$session_bus" ]; then
    export DBUS_SESSION_BUS_ADDRESS="$session_bus"

    echo "  orientation-lock gsetting:"
    log_run gsettings get org.gnome.settings-daemon.peripherals.touchscreen orientation-lock 2>/dev/null || echo "    unavailable"

    echo "  PanelOrientationManaged:"
    log_run gdbus call --session \
        --dest org.gnome.Mutter.DisplayConfig \
        --object-path /org/gnome/Mutter/DisplayConfig \
        --method org.freedesktop.DBus.Properties.Get \
        org.gnome.Mutter.DisplayConfig PanelOrientationManaged 2>/dev/null || echo "    unavailable"

    echo "  touch-mode (ClutterSeat):"
    log_run gdbus call --session \
        --dest org.gnome.Shell \
        --object-path /org/gnome/Shell \
        --method org.freedesktop.DBus.Properties.Get \
        org.gnome.Shell TouchMode 2>/dev/null || echo "    unavailable"

    echo "  Display transform (current state):"
    log_run gdbus call --session \
        --dest org.gnome.Mutter.DisplayConfig \
        --object-path /org/gnome/Mutter/DisplayConfig \
        --method org.gnome.Mutter.DisplayConfig.GetCurrentState 2>&1 | \
        grep -oP 'uint32 \d+' | head -4 | tr '\n' ' '
    echo ""
else
    echo "  (no graphical session found — run as logged-in user or set DBUS_SESSION_BUS_ADDRESS)"
fi
echo ""

heading "gpio-keys input device (hall effect / lid switch)"
gpio_ev=""
for ev in /sys/class/input/event*/device/name; do
    if [ "$(cat "$ev" 2>/dev/null)" = "gpio-keys" ]; then
        gpio_ev="$(dirname "$(dirname "$ev")")"
        gpio_dev="/dev/input/$(basename "$(dirname "$ev")")"
        echo "  Device: $gpio_dev"
        echo "  Capabilities SW: $(cat "$gpio_ev/device/capabilities/sw" 2>/dev/null)"
        echo "  Capabilities KEY: $(cat "$gpio_ev/device/capabilities/key" 2>/dev/null)"
        echo "  udev properties:"
        log_run udevadm info "$gpio_dev" 2>/dev/null | grep -E "ID_INPUT|TAGS" | sed 's/^/    /'
        break
    fi
done
[ -z "$gpio_ev" ] && echo "  gpio-keys device not found"
echo ""

heading "UPower lid state"
log_run busctl get-property org.freedesktop.UPower /org/freedesktop/UPower \
    org.freedesktop.UPower LidIsClosed 2>/dev/null | sed 's/^/  /' || echo "  UPower not available"
log_run busctl get-property org.freedesktop.UPower /org/freedesktop/UPower \
    org.freedesktop.UPower LidIsPresent 2>/dev/null | sed 's/^/  /' || true
echo ""

heading "logind lid switch handling"
log_run busctl get-property org.freedesktop.login1 /org/freedesktop/login1 \
    org.freedesktop.login1.Manager LidClosed 2>/dev/null | sed 's/^/  /'
log_run busctl get-property org.freedesktop.login1 /org/freedesktop/login1 \
    org.freedesktop.login1.Manager HandleLidSwitch 2>/dev/null | sed 's/^/  /'
echo ""

heading "logind.conf.d drop-ins"
for f in /usr/lib/systemd/logind.conf.d/*.conf /etc/systemd/logind.conf.d/*.conf; do
    [ -f "$f" ] && echo "  $f:" && grep -v '^#' "$f" | grep -v '^$' | sed 's/^/    /'
done 2>/dev/null || echo "  none"
echo ""

heading "logind sessions"
log_run loginctl list-sessions --no-pager 2>/dev/null | head -5
echo ""

heading "polkit rule"
log_run cat /usr/share/polkit-1/rules.d/10-iio-sensor-proxy.rules 2>/dev/null || echo "  not present"
echo ""

heading "monitor-sensor (5s live test)"
log_run timeout 5 monitor-sensor 2>&1 || echo "  monitor-sensor not available"

section "CAMERA"

heading "camera modules"
log_run lsmod | grep -iE "camss|cci|s5kjn1|imx858|dw9719|venus|v4l2" || echo "  none loaded"
echo ""

heading "try loading qcom-camss"
if ! lsmod | grep -q qcom_camss; then
    log_run modprobe qcom-camss 2>&1 && echo "  loaded qcom-camss" || echo "  FAILED to load qcom-camss"
else
    echo "  already loaded"
fi
echo ""

heading "camera clock controller (camcc)"
log_run dmesg | grep -iE "camcc" | head -5
log_run ls /sys/kernel/debug/clk/ 2>/dev/null | grep -i cam | head -10 || true
echo ""

heading "CCI I2C buses"
log_run dmesg | grep -iE "qcom-cci|i2c.*cci" | head -10
log_run ls /sys/bus/i2c/devices/ 2>/dev/null | head -20
echo ""

heading "camera sensor dmesg"
log_run dmesg | grep -iE "s5kjn1|imx858|dw9719|dw9800|camera|camss" | head -20
echo ""

heading "media/video devices"
log_run ls -la /dev/video* 2>/dev/null || echo "  no video devices"
log_run ls -la /dev/media* 2>/dev/null || echo "  no media devices"
log_run ls -la /dev/v4l-subdev* 2>/dev/null || echo "  no v4l subdevices"
echo ""

heading "media-ctl topology"
log_run media-ctl -p 2>/dev/null | head -50 || echo "  media-ctl not available or no media devices"
echo ""

heading "deferred probe"
log_run cat /sys/kernel/debug/devices_deferred 2>/dev/null | head -20 || echo "  unavailable"
echo ""

heading "LPASS / audio CC status"
echo "  LPASS device bound:"
if [ -L /sys/bus/platform/devices/3300000.clock-controller/driver ]; then
    log_run readlink /sys/bus/platform/devices/3300000.clock-controller/driver
else
    echo "    NOT BOUND"
    echo "  Deferred probe check:"
    grep -q "3300000.clock-controller" /sys/kernel/debug/devices_deferred 2>/dev/null && \
        echo "    in deferred list" || echo "    not in deferred list"
fi
echo ""

heading "LPASS / audio CC dmesg"
log_run dmesg | grep -iE "lpass|audio_cc" | tail -10

section "DMESG ERRORS"

log_run dmesg --level=emerg,alert,crit,err
echo ""

echo "======== Debug report complete ========"
