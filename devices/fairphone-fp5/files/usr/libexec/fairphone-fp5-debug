#!/bin/bash

echo "========================================"
echo "Fairphone 5 Debug Report — $(date -Iseconds)"
echo "========================================"
echo ""

echo "=== Kernel ==="
uname -r
echo ""

echo "=== Systemd ==="
systemctl --version | head -1
echo ""

echo "=== Key services ==="
for svc in \
    bluetooth.service \
    hexagonrpcd-adsp-sensorspd.service \
    iio-sensor-proxy.service \
    rmtfs.service \
    tqftpserv.service; do
    state=$(systemctl is-active "$svc" 2>/dev/null)
    enabled=$(systemctl is-enabled "$svc" 2>/dev/null)
    printf "  %-45s active=%-10s enabled=%s\n" "$svc" "$state" "$enabled"
done
echo ""

echo "=== Remoteproc ==="
for rproc in /sys/class/remoteproc/remoteproc*/; do
    [ -f "${rproc}name" ] && echo "  $(basename "$rproc"): $(cat "${rproc}name") — $(cat "${rproc}state")"
done
echo ""

echo "=== PD mapper ==="
lsmod | grep qcom_pd_mapper || echo "  qcom_pd_mapper module not loaded"
echo ""

echo "=== QRTR ==="
if command -v qrtr-lookup &>/dev/null; then
    qrtr-lookup 2>/dev/null | head -20
else
    echo "  qrtr-lookup not available"
    ls /sys/bus/qrtr/devices/ 2>/dev/null || echo "  no QRTR devices"
fi
echo ""

echo "==============================="
echo "  BLUETOOTH"
echo "==============================="
echo ""

echo "--- BT firmware files ---"
ls -la /usr/lib/firmware/qca/msbtfw11.* /usr/lib/firmware/qca/msnv11.* 2>/dev/null || echo "  none"
echo ""

echo "--- BT firmware conflicts check ---"
echo "  Compressed firmware that should NOT exist (conflicts with FairBlobs):"
bt_conflicts=$(find /usr/lib/firmware/qca/ -maxdepth 1 \( -name 'msbtfw11.*.xz' -o -name 'msbtfw11.*.zst' -o -name 'msnv11.*.xz' -o -name 'msnv11.*.zst' \) 2>/dev/null)
if [ -n "$bt_conflicts" ]; then
    echo "$bt_conflicts" | while read -r f; do ls -la "$f"; done
else
    echo "  none (good)"
fi
echo "  .tlv symlink check:"
ls -la /usr/lib/firmware/qca/msbtfw11.tlv 2>/dev/null || echo "  MISSING — driver tries .tlv first, should be symlink to .mbn"
echo "  Firmware in initramfs:"
lsinitrd 2>/dev/null | grep -E "msbtfw|msnv" || echo "  not found in initramfs (check dracut config)"
echo ""

echo "--- BT devices ---"
ls -la /sys/class/bluetooth/ 2>/dev/null || echo "  none"
echo ""

echo "--- BT modules ---"
lsmod | grep -E "bluetooth|btqca|hci_uart|rfkill" || echo "  none loaded"
echo ""

echo "--- rfkill ---"
rfkill list bluetooth 2>/dev/null || echo "  unavailable"
echo ""

echo "--- bluetoothctl ---"
timeout 3 bluetoothctl show 2>/dev/null | grep -E "Powered|PowerState|Name|Controller" || echo "  no controller"
echo ""

echo "--- btmgmt info ---"
btmgmt info 2>&1 || true
echo ""

echo "--- BT dmesg ---"
dmesg | grep -iE "bluetooth|qca.*setup|hci|btqca" | tail -20
echo ""

echo "--- BT systemd drop-ins ---"
ls -la /usr/lib/systemd/system/bluetooth.service.d/ 2>/dev/null || echo "  none"
echo ""

echo "--- BT service logs ---"
journalctl -b 0 -u bluetooth.service --no-pager -n 15 2>/dev/null
echo ""

echo "==============================="
echo "  SENSORS & AUTO-ROTATION"
echo "==============================="
echo ""

echo "--- fastrpc devices ---"
ls -la /dev/fastrpc-* 2>/dev/null || echo "  none"
echo ""

echo "--- hexagonrpcd config ---"
cat /usr/share/hexagonrpcd/hexagonrpcd-adsp-sensorspd.conf 2>/dev/null || echo "  MISSING"
echo ""

echo "--- hexagonrpcd status ---"
systemctl status hexagonrpcd-adsp-sensorspd.service --no-pager -n 5 2>/dev/null
echo ""

echo "--- sensor persist directory ---"
ls -la /mnt/vendor/persist/sensors/registry/ 2>/dev/null || echo "  MISSING — ADSP sensor calibration will fail"
ls -la /mnt/vendor/persist/sensors/registry/registry/ 2>/dev/null || echo "  MISSING — ADSP temp.json writes will fail"
echo ""

echo "--- udev env on fastrpc-adsp ---"
udevadm info /dev/fastrpc-adsp 2>/dev/null | grep -E "IIO_SENSOR_PROXY_TYPE|ACCEL_MOUNT_MATRIX" || echo "  no env vars set"
echo ""

echo "--- iio-sensor-proxy binary ---"
rpm -q iio-sensor-proxy 2>/dev/null
ldd /usr/libexec/iio-sensor-proxy 2>/dev/null | grep -iE "ssc|qrtr" || echo "  no SSC/QRTR libs linked"
echo ""

echo "--- iio-sensor-proxy systemd drop-ins ---"
ls -la /usr/lib/systemd/system/iio-sensor-proxy.service.d/ 2>/dev/null || echo "  none"
echo ""

echo "--- iio-sensor-proxy service config ---"
systemctl cat iio-sensor-proxy.service 2>/dev/null | grep -E "RestrictAddress|ExecStart|BusName|PrivateNetwork|Restart|After|Wants"
echo ""

echo "--- iio-sensor-proxy resolved sandbox settings ---"
systemctl show iio-sensor-proxy.service -p RestrictAddressFamilies -p PrivateNetwork 2>/dev/null
echo ""

echo "--- iio-sensor-proxy SELinux ---"
echo "SELinux mode: $(getenforce 2>/dev/null || echo 'N/A')"
semodule -lfull 2>/dev/null | grep -i qrtr || echo "  qrtr SELinux module not installed"
ausearch -m avc --subject iiosensorproxy_t -ts boot 2>/dev/null | grep -c denied | xargs -I{} echo "  AVC denials this boot: {}"
echo ""

echo "--- iio-sensor-proxy service logs ---"
journalctl -b 0 -u iio-sensor-proxy.service --no-pager -n 20 2>/dev/null
echo ""

echo "--- SensorProxy D-Bus properties ---"
gdbus call --system --dest net.hadess.SensorProxy \
    --object-path /net/hadess/SensorProxy \
    --method org.freedesktop.DBus.Properties.GetAll \
    net.hadess.SensorProxy 2>/dev/null || echo "  SensorProxy not available on D-Bus"
echo ""

echo "--- Boot timing: sensor discovery vs GNOME Shell ---"
echo "  iio-sensor-proxy:"
journalctl -b0 -u iio-sensor-proxy.service -o short-monotonic --no-pager 2>/dev/null | head -5
echo "  GNOME Shell:"
journalctl -b0 -o short-monotonic --no-pager 2>/dev/null | grep "gnome-shell\[.*\]: GNOME Shell started" | head -2
echo ""
echo "  If iio-sensor-proxy discovers sensors AFTER GNOME Shell starts,"
echo "  Mutter may not detect the accelerometer. A restart of"
echo "  iio-sensor-proxy.service after login can work around this."
echo ""

echo "--- Mutter orientation manager ---"
if [ -n "$DISPLAY" ] || [ -n "$WAYLAND_DISPLAY" ] || [ -S "/run/user/$(id -u)/bus" ]; then
    echo "  PanelOrientationManaged: $(gdbus call --session \
        --dest org.gnome.Mutter.DisplayConfig \
        --object-path /org/gnome/Mutter/DisplayConfig \
        --method org.freedesktop.DBus.Properties.Get \
        org.gnome.Mutter.DisplayConfig PanelOrientationManaged 2>/dev/null || echo 'unavailable')"
    echo "  orientation-lock: $(gsettings get org.gnome.settings-daemon.peripherals.touchscreen orientation-lock 2>/dev/null || echo 'unavailable')"
    echo "  Display transform: $(gdbus call --session \
        --dest org.gnome.Mutter.DisplayConfig \
        --object-path /org/gnome/Mutter/DisplayConfig \
        --method org.gnome.Mutter.DisplayConfig.GetCurrentState 2>&1 | \
        grep -oP 'uint32 \d+' | head -4 | tr '\n' ' ' || echo 'unavailable')"
else
    echo "  (no session bus — run as logged-in user or set DBUS_SESSION_BUS_ADDRESS)"
fi
echo ""

echo "--- gpio-keys input device (hall effect sensor / lid switch) ---"
gpio_ev=""
for ev in /sys/class/input/event*/device/name; do
    if [ "$(cat "$ev" 2>/dev/null)" = "gpio-keys" ]; then
        gpio_ev="$(dirname "$(dirname "$ev")")"
        gpio_dev="/dev/input/$(basename "$(dirname "$ev")")"
        echo "  Device: $gpio_dev"
        echo "  Capabilities SW: $(cat "$gpio_ev/device/capabilities/sw" 2>/dev/null)"
        echo "  Capabilities KEY: $(cat "$gpio_ev/device/capabilities/key" 2>/dev/null)"
        echo "  udev properties:"
        udevadm info "$gpio_dev" 2>/dev/null | grep -E "ID_INPUT_SWITCH|TAGS" | sed 's/^/    /'
        id_input_switch=$(udevadm info --query=property "$gpio_dev" 2>/dev/null | grep '^ID_INPUT_SWITCH=' | cut -d= -f2)
        if [ -z "$id_input_switch" ] || [ "$id_input_switch" = "0" ]; then
            echo "  SW_LID workaround: ACTIVE (ID_INPUT_SWITCH cleared by udev rule)"
        else
            echo "  ⚠ SW_LID workaround: NOT APPLIED — lid switch is visible to UPower/logind"
        fi
        break
    fi
done
[ -z "$gpio_ev" ] && echo "  gpio-keys device not found"
echo ""

echo "--- UPower lid state (read by Mutter) ---"
busctl get-property org.freedesktop.UPower /org/freedesktop/UPower \
    org.freedesktop.UPower LidIsClosed 2>/dev/null | sed 's/^/  /' || echo "  UPower not available"
busctl get-property org.freedesktop.UPower /org/freedesktop/UPower \
    org.freedesktop.UPower LidIsPresent 2>/dev/null | sed 's/^/  /' || true
echo ""

echo "--- logind lid switch state ---"
busctl get-property org.freedesktop.login1 /org/freedesktop/login1 \
    org.freedesktop.login1.Manager LidClosed 2>/dev/null | sed 's/^/  /'
busctl get-property org.freedesktop.login1 /org/freedesktop/login1 \
    org.freedesktop.login1.Manager HandleLidSwitch 2>/dev/null | sed 's/^/  /'
echo ""

echo "--- logind.conf.d drop-ins ---"
for f in /usr/lib/systemd/logind.conf.d/*.conf /etc/systemd/logind.conf.d/*.conf; do
    [ -f "$f" ] && echo "  $f:" && grep -v '^#' "$f" | grep -v '^$' | sed 's/^/    /'
done 2>/dev/null || echo "  none"
echo ""

echo "--- logind sessions ---"
loginctl list-sessions --no-pager 2>/dev/null | head -5
echo ""

echo "--- polkit rule ---"
cat /usr/share/polkit-1/rules.d/10-iio-sensor-proxy.rules 2>/dev/null || echo "  not present"
echo ""

echo "--- monitor-sensor (5s live test) ---"
timeout 5 monitor-sensor 2>&1 || echo "  monitor-sensor not available"
echo ""

echo "==============================="
echo "  CAMERA"
echo "==============================="
echo ""

echo "--- camera modules ---"
lsmod | grep -iE "camss|cci|s5k|imx|dw9719|dw9719|venus|v4l2" || echo "  none loaded"
echo ""

echo "--- try loading qcom-camss ---"
if ! lsmod | grep -q qcom_camss; then
    modprobe qcom-camss 2>&1 && echo "  loaded qcom-camss" || echo "  FAILED to load qcom-camss"
else
    echo "  already loaded"
fi
echo ""

echo "--- PM8008 camera PMIC ---"
dmesg | grep -iE "pm8008" | head -10
echo ""

echo "--- camera clock controller (camcc) ---"
dmesg | grep -iE "camcc" | head -5
ls /sys/kernel/debug/clk/ 2>/dev/null | grep -i cam | head -10 || true
echo ""

echo "--- CCI I2C buses ---"
dmesg | grep -iE "qcom-cci|i2c.*cci" | head -10
ls /sys/bus/i2c/devices/ 2>/dev/null | head -20
echo ""

echo "--- camera sensor dmesg ---"
dmesg | grep -iE "s5kjn1|imx858|imx471|dw9719|camera|camss" | head -20
echo ""

echo "--- camera regulators ---"
for reg in /sys/class/regulator/regulator.*/; do
    name=$(cat "${reg}name" 2>/dev/null)
    if echo "$name" | grep -qiE "cam|ldo|l[12345]p"; then
        state=$(cat "${reg}state" 2>/dev/null)
        printf "  %-40s %s\n" "$name" "$state"
    fi
done
echo ""

echo "--- media/video devices ---"
ls -la /dev/video* 2>/dev/null || echo "  no video devices"
ls -la /dev/media* 2>/dev/null || echo "  no media devices"
ls -la /dev/v4l-subdev* 2>/dev/null || echo "  no v4l subdevices"
echo ""

echo "--- media-ctl topology ---"
media-ctl -p 2>/dev/null | head -50 || echo "  media-ctl not available or no media devices"
echo ""

echo "--- camera DT nodes ---"
cam_dt_found=false
for node in /sys/firmware/devicetree/base/soc@0/camss* \
            /sys/firmware/devicetree/base/soc@0/*/camera-sensor@* \
            /sys/firmware/devicetree/base/soc@0/*/i2c@*/camera@* \
            /sys/firmware/devicetree/base/soc@0/*/i2c@*/lens@*; do
    if [ -e "$node" ]; then
        echo "  $(echo $node | sed 's|/sys/firmware/devicetree/base/||')"
        cam_dt_found=true
    fi
done 2>/dev/null
if [ "$cam_dt_found" = false ]; then
    echo "  no camera DT nodes found"
fi
echo ""

echo "--- deferred probe ---"
cat /sys/kernel/debug/devices_deferred 2>/dev/null | head -20 || echo "  unavailable (debugfs not mounted or no access)"
echo ""

echo "--- LPASS / audio CC dmesg ---"
dmesg | grep -iE "lpass|audio_cc" | tail -10
echo ""

echo "==============================="
echo "  DMESG ERRORS"
echo "==============================="
echo ""
dmesg --level=emerg,alert,crit,err
echo ""

echo "======== Debug report complete ========"
